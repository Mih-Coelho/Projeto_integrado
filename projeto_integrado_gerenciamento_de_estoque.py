# -*- coding: utf-8 -*-
"""Projeto_integrado_gerenciamento_de_estoque.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gPWiHICYMLp6SJCbLL04iHTah_KV-X-I
"""

#Inicialização de variáveis

produtos = {}
movimentacoes = []
id_produto_counter = 1
id_movimentacao_counter = 1

# Funções para Cadastro de Produtos e Categorias:

#Cadastrar categoria
# Estrutura de Dados para Categorias

class categoria:
    # Variáveis de classe para manter o contador e as categorias
    id_categoria_counter = 0
    categorias = {}

    @classmethod
    def cadastrar_categoria(cls, nome):
        if not nome:
            raise ValueError("Nome da categoria não pode estar em branco.")

        cls.id_categoria_counter += 1
        cls.categorias[cls.id_categoria_counter] = nome
        print(f"Categoria '{nome}' cadastrada com sucesso! ID: {cls.id_categoria_counter}")
        return cls.id_categoria_counter  # Retorna o ID da nova categoria

    @classmethod
    def consultar_categoria(cls, id_categoria):
      return cls.categorias.get(id_categoria, "Categoria não encontrada.")


#Cadastro de produto
# Estrutura de Dados para Produtos

class produto:
    def __init__(self, id_produto, nome, id_categoria, quantidade, preco, localizacao):
        self.id_produto = id_produto
        self.nome = nome
        self.id_categoria = id_categoria
        self.quantidade = quantidade
        self.preco = preco
        self.localizacao = localizacao

#Criando uma string formatada para melhor visualização do usuário

    def __str__(self):
        return (f"ID: {self.id_produto}, Nome: {self.nome}, "
                f"Categoria ID: {self.id_categoria}, Quantidade: {self.quantidade}, "
                f"Preço: R${self.preco:.2f}, Localização: {self.localizacao}")

    @classmethod
    def cadastrar_produto(cls, nome, id_categoria, quantidade, preco, localizacao):
        global id_produto_counter
        if id_categoria not in categoria.categorias:
            raise ValueError("Categoria não encontrada.")

        novo_produto = cls(id_produto_counter, nome, id_categoria, quantidade, preco, localizacao)
        produtos[id_produto_counter] = novo_produto
        id_produto_counter += 1
        print(f"Produto '{nome}' cadastrado com sucesso! ID: {id_produto_counter - 1}")
        return id_produto_counter - 1  # Retorna o ID do novo produto

# Função de consulta de produto

def consultar_produto(id_produto):
    produto_encontrado = produtos.get(id_produto)
    if produto_encontrado:
        print(produto_encontrado)  # Chama o método __str__
    else:
        print("Produto não encontrado.")


# Funções para Registrar Entradas e Saídas de Produtos:
# Cadastrar Movimentações de Estoque
# Estrutura de Dados para Movimentações de Estoque

class movimentacao:
    def __init__(self, id_movimentacao, id_produto, tipo, quantidade, data):
        self.id_movimentacao = id_movimentacao
        self.id_produto = id_produto
        self.tipo = tipo  # 'entrada' ou 'saida'
        self.quantidade = quantidade
        self.data = data

    @classmethod
    def registrar_movimentacao(cls, id_produto, tipo, quantidade, data):
        global id_movimentacao_counter
        if id_produto not in produtos:
            raise ValueError("Produto não encontrado.")
        if tipo not in ['entrada', 'saida']:
            raise ValueError("Tipo de movimentação inválida.")

        produto_obj = produtos[id_produto]
        if tipo == 'saida' and produto_obj.quantidade < quantidade:
            raise ValueError("Quantidade insuficiente em estoque.")

        # Cria uma nova movimentação
        movimentacao_obj = cls(id_movimentacao_counter, id_produto, tipo, quantidade, data)
        movimentacoes.append(movimentacao_obj)

        # Atualiza a quantidade do produto
        if tipo == 'entrada':
            produto_obj.quantidade += quantidade
        else:
            produto_obj.quantidade -= quantidade

        print(f"Movimentação de {tipo} de {quantidade} unidades do produto '{produto_obj.nome}' registrada com sucesso!")
        id_movimentacao_counter += 1  # Incrementa o contador de movimentação
        return movimentacao_obj

    @classmethod
    def gerar_relatorio_estoque(cls, id_produto=None):
        relatorio = []
        for id_p, produto in produtos.items():
            if id_produto is None or id_produto == id_p:
                relatorio.append({
                    'id_produto': id_p,
                    'nome': produto.nome,
                    'categoria': categoria.categorias[produto.id_categoria],
                    'quantidade': produto.quantidade,
                    'preco': produto.preco,
                    'localizacao': produto.localizacao
                })
        return relatorio

    @classmethod
    def consultar_movimentacoes(cls, id_produto=None):
        historico = []
        for mov in movimentacoes:
            if id_produto is None or mov.id_produto == id_produto:
                historico.append({
                    'id_movimentacao': mov.id_movimentacao,
                    'id_produto': mov.id_produto,
                    'tipo': mov.tipo,
                    'quantidade': mov.quantidade,
                    'data': mov.data
                })
        return historico

#Menu interativo

while True:
  print("O que você deseja fazer?")
  print("1 - Cadastrar Produtos")
  print("2 - Cadastrar Categorias")
  print("3 - Cadastrar Movimentações de Estoque")
  print("4 - Consultar Produtos")
  print("5 - Consultar Categorias")
  print("6 - Gerar Relatórios de Estoque")
  print("7 - Gerar Relatórios de Movimentações")
  print("8 - Sair")
  resposta = int(input("Escolha uma opção: "))

#Escolha opção "1" - Cadastro de produto
  if resposta == 1:
    nome = input("Digite o nome do produto: ")
    id_categoria = int(input("Digite o ID da categoria do produto: "))
    quantidade = int(input("Digite a quantidade do produto: "))
    preco = float(input("Digite o preço do produto: "))
    localizacao = input("Digite a localização do produto: ")
    if id_categoria not in categoria.categorias:
      print("Categoria não encontrada. Por favor, cadastre a categoria antes de cadastrar o produto.")
      exit()
    else:
      id_produto = produto.cadastrar_produto(nome, id_categoria, quantidade, preco, localizacao)
      print(f"Produto '{nome}' cadastrado com sucesso!")
      print(f"ID do produto {id_produto}")

#Escolha opção "2" - Cadastro de categoria
  elif resposta == 2:
    nome = input("Digite o nome da categoria: ")
    categoria.cadastrar_categoria(nome)

#Escolha opção "3" - Cadastrar movimentações de estoque
  elif resposta == 3:
    id_produto = int(input("Digite o ID do produto: "))
    tipo = input("Digite o tipo de movimentação (entrada/saida): ")
    quantidade = int(input("Digite a quantidade movimentada: "))
    data = input("Digite a data da movimentação (DD/MM/AAAA): ")
    movimentacao.registrar_movimentacao(id_produto, tipo, quantidade, data)
    print(f"Movimentação de {tipo} de {quantidade} unidades do produto com ID {id_produto} registrada com sucesso!")

#Escolha opção "4" - Consultar produtos
  elif resposta == 4:
    id_produto = int(input("Digite o ID do produto: "))
    consultar_produto(id_produto)

#Escolha opção "5" - Consultar categoria
  elif resposta == 5:
    id_categoria = int(input("Digite o ID da categoria: "))
    print(categoria.consultar_categoria(id_categoria))

#Escolha opção "6" - Gerar relatório de estoque
  elif resposta == 6:
    id_produto = int(input("Digite o ID do produto: "))
    print(movimentacao.gerar_relatorio_estoque(id_produto))

#Escolha opção "7" - Gerar relatório de movimentação
  elif resposta == 7:
        id_produto = int(input("Digite o ID do produto (ou deixe em branco para todos): ") or 0)
        relatorio_movimentacoes = movimentacao.consultar_movimentacoes(id_produto if id_produto != 0 else None)
        for mov in relatorio_movimentacoes:
            print(mov)

#Escolha opção "8" - Sair do programa
  elif resposta == 8:
    print("Saindo do programa...")
    exit()
    break

#Nenhuma das opções
  else:
    print("Opção inválida. Por favor, tente novamente.")